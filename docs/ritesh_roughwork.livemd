# Ritesh's Rough Work on Vyasa

## Root Section -- Common Utils

### Supports Recompilation from within Livebook

```elixir
defmodule R do
  def recompile() do
    Mix.Task.reenable("app.start")
    Mix.Task.reenable("compile")
    Mix.Task.reenable("compile.all")
    compilers = Mix.compilers()
    Enum.each(compilers, &Mix.Task.reenable("compile.#{&1}"))
    Mix.Task.run("compile.all")
  end
end

R.recompile()
```

### Some Creation functions to create maps that can be used by changesets:

Convert json --> struct --> using changeset --> insert into repo

```elixir
alias Vyasa.Written.{Chapter, Source}
alias Vyasa.Repo

defmodule G do
  @root "/Users/ritesh/Projects/vyasa"
  @gita_sub_dir "#{@root}/priv/static/corpus/gita"

  @verses "#{@gita_sub_dir}/verse.json"
  @chapters "#{@gita_sub_dir}/chapters.json"

  alias Vyasa.Written.{Chapter}

  def get_verses(source_id) do
    @verses
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn verse -> create_verse(verse, source_id) end)
  end

  def get_verses() do
    @verses
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn verse -> G.create_verse(verse) end)
  end

  def create_verse(verse, source_id) do
    %{
      source_id: source_id,
      chapter_no: verse["chapter_number"],
      body: verse["text"],
      no: verse["verse_number"]
      # transliterations: [create_transliteration(verse)],
    }
  end

  def create_verse(verse) do
    %{
      source_id: nil,
      chapter_no: verse["chapter_number"],
      body: verse["text"],
      no: verse["verse_number"]
      # transliterations: [create_transliteration(verse)],
    }
  end

  def create_transliteration(%{} = verse) do
    %{
      lang: "en",
      body: verse["transliteration"],
      meaning: verse["word_meanings"]
    }
  end

  def create_translation(%{} = _verse) do
    %{
      lang: "en",
      body: "body"
    }
  end

  def create_chapter(%{} = chapter, [%{} = _head | _rest] = verses, source_id) do
    IO.puts("CHECK THIS CHAPTER OUT")
    IO.inspect(chapter)

    %{
      source_id: source_id,
      no: chapter["chapter_number"],
      body: chapter["chapter_summary"],
      title: chapter["name_meaning"],
      indic_name: chapter["name"],
      indic_name_meaning: chapter["name_meaning"],
      indic_summary: chapter["chapter_summary_hindi"],
      indic_name_translation: chapter["name_translation"],
      indic_name_transliteration: chapter["name_transliterated"],
      verses: Enum.filter(verses, fn %{chapter_no: num} -> chapter["chapter_number"] == num end)
    }
  end

  def get_chapters([%{} = _head | _rest] = verses, source_id) do
    @chapters
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn chap -> create_chapter(chap, verses, source_id) end)
  end

  def add_relevant_verses(chapter, verses) do
    relevant_verses =
      verses
      |> Enum.filter(fn verse -> verse.chapter_no == chapter.no end)
      |> Enum.map(fn verse -> Map.put(verse, :id, Ecto.UUID.generate()) end)

    %{chapter | verses: relevant_verses}
  end

  def insert_verses_into_chapters(chapters, verses) do
    chapters
    |> Enum.map(fn chap -> add_relevant_verses(chap, verses) end)
  end

  def get_source([%{} = _h | _r] = chapters, [%{} = _head | _rest] = verses, source_id) do
    %{
      id: source_id,
      title: "Gita",
      chapters: chapters,
      verses: verses
    }
  end

  def create_changeset(chapter) do
    # IO.inspect(chapter["chapter_number"])
    IO.inspect(chapter)

    %{
      "chapter_number" => num,
      "chapter_summary" => body
    } = chapter

    changeset = Chapter.changeset(%Chapter{}, %{num: num, body: body})

    changeset
  end
end
```

```elixir
# improving on the get-* functions 

sid = Ecto.UUID.generate()

verses = G.get_verses(sid)
chapters = G.get_chapters(verses, sid)
```

#### DB Convenience Actions

* purging of db
* seeding of db

```elixir
defmodule DBHelper do
  alias Vyasa.Repo
  alias G
  alias Vyasa.Written.{Source, Chapter, Verse, Transliteration}

  def purge_db() do
    [Verse, Chapter, Source, Transliteration]
    |> Enum.map(fn mod -> Repo.delete_all(mod) end)
  end

  def seed_db() do
    src =
      Source.gen_changeset(
        %Source{
          title: "Gita"
        },
        %{}
      )
      |> Repo.insert!()

    verses = G.get_verses(src.id)

    chapters =
      G.get_chapters(verses, src.id)
      |> G.insert_verses_into_chapters(verses)

    src
    |> Repo.preload([:chapters, verses: :chapter])
    |> Source.mutate_changeset(%{
      chapters: chapters
    })
    |> Repo.update!()
  end
end
```

```elixir
id = Ecto.UUID.generate()
verses = G.get_verses(id)
chaps = G.get_chapters(verses, id) |> G.insert_verses_into_chapters(verses)
```

```elixir
R.recompile()
DBHelper.purge_db()
DBHelper.seed_db()
```

```elixir
R.recompile()sr
alias Vyasa.Written

Written.get_source_by_title("Gita")
```

<!-- livebook:{"branch_parent_index":0} -->

## Exploration

```elixir
DBHelper.purge_db()
DBHelper.seed_db()

alias Vyasa.Written
sources = Written.list_sources() |> Repo.preload([:chapters, :verses])
s = hd(sources)
v = hd(s.verses)
c = hd(s.chapters)
Map.keys(c)
c

# Written.get_source!(hd(sources).id)
```

```elixir
DBHelper.seed_db()
```

```elixir
R.recompile()

alias Vyasa.Written

Written.list_sources()

[%Source{id: id} = _hd | tail] = Written.list_sources()
Written.get_source!(id)
Written.get_chapter!(2, id)
```

<!-- livebook:{"branch_parent_index":0} -->

## 2) Cloning Gita by Creating a Schema for it

### Actually creating entries:

<!-- livebook:{"break_markdown":true} -->

#### Improving the ingestion to include missed attributes

<!-- livebook:{"break_markdown":true} -->

### Check Queries

```elixir
R.recompile()
alias Vyasa.Written

# Written.get_chapter(1, "6682956d-0e29-4c3f-a4b3-5e24baf0c9da")

# Written.get_verse_via_url_params(8,"1","a619b2fa-3ec8-4dcc-b878-b2a80d48b38a") |> dbg()

# Written.get_source_by_title("Gita")
# |> Enum.find(fn src -> src.title == "gita" end)

chapter =
  Repo.get_by(Chapter, no: 2, source_id: "a619b2fa-3ec8-4dcc-b878-b2a80d48b38a")
  |> Repo.preload([:verses, :source])

verse_no = 2

chapter.verses
|> Enum.find(fn verse -> verse.no == verse_no end)
|> Repo.preload([:source, :chapter])
```

```elixir

```

#### Session Creation
