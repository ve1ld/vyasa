# 2024 - An Ecto Odessy [Initial DB Helpers]

## Root Section -- Common Utils

### Supports Recompilation from within Livebook

```elixir
defmodule R do
  def recompile() do
    Mix.Task.reenable("app.start")
    Mix.Task.reenable("compile")
    Mix.Task.reenable("compile.all")
    compilers = Mix.compilers()
    Enum.each(compilers, &Mix.Task.reenable("compile.#{&1}"))
    Mix.Task.run("compile.all")
  end
end

R.recompile()
```

### Some Creation functions to create maps that can be used by changesets:

Convert json --> struct --> using changeset --> insert into repo

```elixir
alias Vyasa.Written.{Chapter, Source, Translation}
alias Vyasa.Repo

defmodule G do
  @root "/Users/ritesh/Projects/vyasa"
  @gita_sub_dir "#{@root}/priv/static/corpus/gita"

  @verses "#{@gita_sub_dir}/verse.json"
  @chapters "#{@gita_sub_dir}/chapters.json"

  alias Vyasa.Written.{Chapter}

  def read_verses() do
    @verses
    |> File.read!()
    |> Jason.decode!()
  end

  def read_chapters() do
    @chapters
    |> File.read!()
    |> Jason.decode!()
  end

  def create_verse(verse, source_id) do
    updated =
      verse
      |> Map.put("source_id", source_id)
      |> Map.put("chapter_no", verse["chapter_number"])
      |> Map.put("body", verse["text"])
      |> Map.put("no", verse["verse_number"])

    dbg(updated)
  end

  def get_verses_for_chapter(chap_no, src_id) do
    read_verses()
    |> Enum.filter(fn verse -> verse["chapter_number"] == chap_no end)
    |> Enum.map(fn verse -> G.create_verse(verse, src_id) end)
  end

  def create_translation_for_chapter(chapter) do
    %{
      type: "chapters",
      lang: "sa",
      target: %{
        title: chapter["name"],
        translit_title: chapter["name_transliterated"],
        body: chapter["chapter_summary_hindi"],
        body_translit: chapter["chapter_summary"]
      }
    }
  end

  def create_chapter(%{} = chapter, source_id) do
    %{
      no: chapter["chapter_number"],
      body: chapter["chapter_summary"],
      source_id: source_id
    }
    |> dbg()
  end

  def create_chapter(%{} = chapter, [%{} = _head | _rest] = _verses, source_id) do
    IO.puts("CHECK THIS CHAPTER OUT")
    IO.inspect(chapter)

    %{
      source_id: source_id,
      no: chapter["chapter_number"]
    }
  end

  def get_chapters([%{} = _head | _rest] = verses, source_id) do
    @chapters
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn chap -> create_chapter(chap, verses, source_id) end)
  end

  def get_chapters(source_id) do
    @chapters
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn chap -> create_chapter(chap, source_id) end)
  end

  def add_relevant_verses(chapter, verses) do
    relevant_verses =
      verses
      |> Enum.filter(fn verse -> verse.chapter_no == chapter.no end)
      |> Enum.map(fn verse -> Map.put(verse, :id, Ecto.UUID.generate()) end)

    %{chapter | verses: relevant_verses}
  end

  def insert_verses_into_chapters(chapters, verses) do
    chapters
    |> Enum.map(fn chap -> add_relevant_verses(chap, verses) end)
  end

  def get_source([%{} = _h | _r] = chapters, [%{} = _head | _rest] = verses, source_id) do
    %{
      id: source_id,
      title: "Gita",
      chapters: chapters,
      verses: verses
    }
  end

  def create_chapter_changeset(chap, verses, src_id) do
    Chapter.changeset(
      %Chapter{
        no: chap["chapter_number"],
        source_id: src_id,
        title: chap["name"],
        body: chap["chapter_summary"]
      },
      %{
        verses: verses
      }
    )
  end

  def create_chap_translation_changeset(%Chapter{} = inserted_chap, %{} = chap) do
    Translation.gen_changeset(
      %Translation{},
      %{
        lang: "en",
        body: chap["chapter_summary"],
        target: %{
          title: chap["name_meaning"],
          translit_title: chap["name_transliterated"],
          body: chap["chapter_summary"],
          body_meant: chap["chapter_summary_hindi"]
        }
      },
      inserted_chap
    )
  end

  def create_translation_changeset_for_verse(inserted_verse, relevant_verse) do
    dbg(relevant_verse)

    Translation.gen_changeset(
      %Translation{},
      %{
        lang: "en",
        # body: verse["transliteration"],
        target: %{
          body: relevant_verse["text"],
          body_translit_meant: relevant_verse["word_meanings"],
          body_translit: relevant_verse["transliteration"]
        }
      },
      inserted_verse
    )
    |> dbg()
  end

  def create_translation_changesets_for_verses(inserted_verses, relevant_verses) do
    Enum.zip(inserted_verses, relevant_verses)
    |> Enum.map(fn {inserted_verse, relevant_verse} ->
      create_translation_changeset_for_verse(inserted_verse, relevant_verse)
    end)
  end
end
```

#### DB Convenience Actions

* purging of db
* seeding of db

```elixir
defmodule DBHelper do
  alias Vyasa.Repo
  alias G
  alias Vyasa.Written.{Source, Chapter, Verse, Transliteration, Translation}

  def purge_db() do
    [Translation, Verse, Chapter, Source, Transliteration]
    |> Enum.map(fn mod -> Repo.delete_all(mod) end)
  end

  def seed_db() do
    uuid = Ecto.UUID.generate()
    _source = DBHelper.insert_source(uuid, "Gita")
    DBHelper.insert_chapters(uuid)
  end

  def insert_source(uuid, source_title \\ "Gita") do
    source_changeset =
      Source.gen_changeset(%Source{}, %{
        id: uuid,
        title: source_title
      })

    Repo.insert!(source_changeset)
  end

  def insert_chapter(chap, source_id) do
    relevant_verses = G.get_verses_for_chapter(chap["chapter_number"], source_id)
    chap_changeset = G.create_chapter_changeset(chap, relevant_verses, source_id)
    {:ok, %Chapter{} = inserted_chapter} = Repo.insert(chap_changeset)
    %{verses: inserted_verses} = inserted_chapter

    changeset_chap_translation = G.create_chap_translation_changeset(inserted_chapter, chap)
    {:ok, %Translation{} = _inserted_chap_translation} = Repo.insert(changeset_chap_translation)

    verses_translation_changesets =
      G.create_translation_changesets_for_verses(inserted_verses, relevant_verses)

    _inserted_verse_translations =
      verses_translation_changesets
      |> Enum.map(fn c_set -> Repo.insert(c_set) end)
      |> Enum.map(fn {:ok, inserted_verse_translation} -> inserted_verse_translation end)
  end

  def insert_chapters(source_id) do
    G.read_chapters()
    |> Enum.map(fn chap -> insert_chapter(chap, source_id) end)
  end
end
```

#### Testing the purging and seeding of the db:

```elixir
R.recompile()
DBHelper.purge_db()
DBHelper.seed_db()
```

```elixir
### checking the query functions

alias Vyasa.Written
alias Vyasa.Repo

R.recompile()

src =
  Written.list_sources()
  |> Enum.find(fn src -> src.title == "Gita" end)
```

##### Bala's working example of using the polymorphic translations

<!-- livebook:{"break_markdown":true} -->

Typically, we can select which changeset to use via the :with option. This won't work in our case because our APIs for changeset has 3 args (opp to 2 arg convention). There's no repercussion in doing it as a 2-step process now.

Translations is expected to be added after chapter and verse has been added. The existing chain of changesets won't work automatically like that. Nested assocs won't work here.

Therefore, the seed_db() needs to be updated so that the translations will be added later.

It becomes 3 steps as shown in the block below:

```elixir
source =
  Vyasa.Written.Source.gen_changeset(%Vyasa.Written.Source{}, %{
    id: Ecto.UUID.generate(),
    title: "gita_v2"
  })
  |> Vyasa.Repo.insert!()

{:ok, %{verses: [verse | _]} = chapter} =
  Chapter.changeset(
    %Chapter{no: 5, source_id: source.id},
    %{
      verses: [
        %{no: 1, body: "Kurukshetra", source_id: source.id}
      ]
    }
  )
  |> Vyasa.Repo.insert()

Vyasa.Written.Translation.gen_changeset(
  %Vyasa.Written.Translation{},
  %{
    lang: "en",
    body: "अर्जुनविषादयोग",
    target: %{title: "Arjuna Vishada-yoga"}
  },
  chapter
)
|> Vyasa.Repo.insert()
```

```elixir
id = Ecto.UUID.generate()
verses = G.get_verses(id)
chaps = G.get_chapters(verses, id) |> G.insert_verses_into_chapters(verses)
hd(chaps)
```

```elixir
R.recompile()
DBHelper.purge_db()
DBHelper.seed_db()
```

<!-- livebook:{"branch_parent_index":0} -->

## Exploration

```elixir
# DBHelper.purge_db()
# DBHelper.seed_db()

alias Vyasa.Written
sources = Written.list_sources() |> Repo.preload([:chapters, :verses])
s = hd(sources)
v = hd(s.verses)
c = hd(s.chapters)
# Map.keys(c)

sources

# Written.get_source!(hd(sources).id)
```

```elixir
R.recompile()

alias Vyasa.Written

Written.list_sources()

[%Source{id: id} = _hd | tail] = Written.list_sources()
Written.get_source!(id)
Written.get_chapter!(2, id)
```

<!-- livebook:{"branch_parent_index":0} -->

## 2) Cloning Gita by Creating a Schema for it

### Check Queries found in the Written context module

<!-- livebook:{"break_markdown":true} -->

###

```elixir
R.recompile()
alias Vyasa.Written

# Written.get_chapter(1, "6682956d-0e29-4c3f-a4b3-5e24baf0c9da")

# Written.get_verse_via_url_params(8,"1","a619b2fa-3ec8-4dcc-b878-b2a80d48b38a") |> dbg()

# Written.get_source_by_title("Gita")
# |> Enum.find(fn src -> src.title == "gita" end)

chapter =
  Repo.get_by(Chapter, no: 2, source_id: "a619b2fa-3ec8-4dcc-b878-b2a80d48b38a")
  |> Repo.preload([:verses, :source])

verse_no = 2

chapter.verses
|> Enum.find(fn verse -> verse.no == verse_no end)
|> Repo.preload([:source, :chapter])
```

#### Session Creation
