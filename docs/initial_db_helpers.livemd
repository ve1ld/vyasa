# 2024 - An Ecto Odessy [Initial DB Helpers]

## Root Section -- Common Utils

### Supports Recompilation from within Livebook

```elixir
defmodule R do
  def recompile() do
    Mix.Task.reenable("app.start")
    Mix.Task.reenable("compile")
    Mix.Task.reenable("compile.all")
    compilers = Mix.compilers()
    Enum.each(compilers, &Mix.Task.reenable("compile.#{&1}"))
    Mix.Task.run("compile.all")
  end
end

R.recompile()
```

### Source Extraction Modules

Convert json --> struct --> using changeset --> insert into repo

<!-- livebook:{"break_markdown":true} -->

#### Gita Source Extraction Module

```elixir
alias Vyasa.Written.{Chapter, Source, Translation}
alias Vyasa.Medium
alias Vyasa.Repo

defmodule G do
  @gita_sub_dir Path.expand("./priv/static/corpus/gita")

  @verses "#{@gita_sub_dir}/verse.json"
  @translations "#{@gita_sub_dir}/translation.json"
  @chapters "#{@gita_sub_dir}/chapters.json"

  alias Vyasa.Written.{Chapter}

  def read_verses() do
    @verses
    |> File.read!()
    |> Jason.decode!()
  end

  def read_translations() do
    @translations
    |> File.read!()
    |> Jason.decode!()
  end

  def read_chapters() do
    @chapters
    |> File.read!()
    |> Jason.decode!()
  end

  def get_translation_by_verse(id) do
    read_translations()
    |> Enum.find(fn %{"verseNumber" => no, "authorName" => a} ->
      no == id and a == "Dr. S. Sankaranarayan"
    end)
  end

  def create_verse(verse, source_id) do
    updated =
      verse
      |> Map.put("source_id", source_id)
      |> Map.put("chapter_no", verse["chapter_number"])
      |> Map.put("body", verse["text"])
      |> Map.put("no", verse["verse_number"])

    updated
  end

  def get_verses_for_chapter(chap_no, src_id) do
    read_verses()
    |> Enum.filter(fn verse -> verse["chapter_number"] == chap_no end)
    |> Enum.map(fn verse -> G.create_verse(verse, src_id) end)
  end

  def create_translation_for_chapter(chapter) do
    %{
      type: "chapters",
      lang: "hi",
      target: %{
        title: chapter["name"],
        body: chapter["chapter_summary_hindi"]
      }
    }
  end

  def create_chapter(%{} = chapter, source_id) do
    %{
      no: chapter["chapter_number"],
      title: chapter["name"],
      body: chapter["chapter_summary"],
      source_id: source_id
    }

    # |> dbg()
  end

  def create_chapter(%{} = chapter, [%{} = _head | _rest] = _verses, source_id) do
    IO.puts("CHECK THIS CHAPTER OUT")
    IO.inspect(chapter)

    %{
      source_id: source_id,
      no: chapter["chapter_number"]
    }
  end

  def get_chapters([%{} = _head | _rest] = verses, source_id) do
    @chapters
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn chap -> create_chapter(chap, verses, source_id) end)
  end

  def get_chapters(source_id) do
    @chapters
    |> File.read!()
    |> Jason.decode!()
    |> Enum.map(fn chap -> create_chapter(chap, source_id) end)
  end

  def add_relevant_verses(chapter, verses) do
    relevant_verses =
      verses
      |> Enum.filter(fn verse -> verse.chapter_no == chapter.no end)
      |> Enum.map(fn verse -> Map.put(verse, :id, Ecto.UUID.generate()) end)

    %{chapter | verses: relevant_verses}
  end

  def insert_verses_into_chapters(chapters, verses) do
    chapters
    |> Enum.map(fn chap -> add_relevant_verses(chap, verses) end)
  end

  def get_source([%{} = _h | _r] = chapters, [%{} = _head | _rest] = verses, source_id) do
    %{
      id: source_id,
      title: "Gita",
      chapters: chapters,
      verses: verses
    }
  end

  def create_chapter_changeset(chap, verses, src_id) do
    Chapter.changeset(
      %Chapter{
        no: chap["chapter_number"],
        source_id: src_id,
        title: chap["name"],
        body: chap["chapter_summary"]
      },
      %{
        verses: verses
      }
    )
  end

  def create_chap_translation_changeset(%Chapter{} = inserted_chap, %{} = chap) do
    Translation.gen_changeset(
      %Translation{},
      %{
        lang: "en",
        body: chap["chapter_summary"],
        target: %{
          title: chap["name_meaning"],
          translit_title: chap["name_transliterated"],
          body: chap["chapter_summary"]
        }
      },
      inserted_chap
    )
  end

  def create_translation_changeset_for_verse(
        inserted_verse,
        %{"verse_order" => verse_id} = relevant_verse
      ) do
    dbg(relevant_verse)

    Translation.gen_changeset(
      %Translation{},
      %{
        lang: "en",
        # body: verse["transliteration"],
        target: %{
          body: get_translation_by_verse(verse_id)["description"],
          body_translit_meant: relevant_verse["word_meanings"],
          body_translit: relevant_verse["transliteration"]
        }
      },
      inserted_verse
    )
    |> dbg()
  end

  def create_translation_changesets_for_verses(inserted_verses, relevant_verses) do
    Enum.zip(inserted_verses, relevant_verses)
    |> Enum.map(fn {inserted_verse, relevant_verse} ->
      create_translation_changeset_for_verse(inserted_verse, relevant_verse)
    end)
  end
end
```

#### Hanuman Chalisa Source Extraction Module

```elixir
defmodule H do
  alias Vyasa.Written.{Chapter, Source, Translation}
  alias Vyasa.Medium
  alias Vyasa.Repo

  @chalisa_events """
  start :- 00:00
  Shloka 1:-    00:02
  Shloka 2 :-   00:24
  Shloka 3:-    00:56
  Shloka 4:-   01:07
  Shloka 5:-   01:23
  Shloka 6:-   01:33
  Shloka 7:-   01:44
  Shloka 8:-   01:55
  Shloka 9:-   02:10
  Shloka 10:-  02:21
  Shloka 11:-  02:32
  Shloka 12:- 02:43
  Shloka 13:- 02:58
  Shloka 14:- 03:09
  Shloka 15:- 03:19
  Shloka 16:- 03:30
  Shloka 17:- 03:45
  Shloka 18:- 03:54
  Shloka 19:- 04:07
  Shloka 20:- 04:18
  Shloka 21:-  04:33
  Shloka 22:-  04:44
  Shloka 23:-  04:55
  Shloka 24:-  05:05
  Shloka 25:- 05:21
  Shloka 26:- 05:32
  Shloka 27:- 05:42
  Shloka 28:- 05:53
  Shloka 29:-  06:09
  Shloka 30:-  06:19
  Shloka 31:-  06:30
  Shloka 32 :-  06:41
  Shloka 33:-   06:56
  Shloka 34 :-  07:07
  Shloka 35 :-  07:17
  Shloka 36 :- 07:28
  Shloka 37:-  07:43
  Shloka 38 :- 07:54
  Shloka 39:-  08:05
  Shloka 40:-  08:16
  Shloka 41:- 08:31
  Shloka 42:- 08:41
  Shloka 43:-  09:00
  end:-  09:42
  """

  @chalisa_json_path Path.expand("./priv/static/corpus/shlokam.org/hanumanchalisa.json")

  def read_verses() do
    @chalisa_json_path
    |> File.read!()
    |> Jason.decode!()
  end
end
```

#### Seeders

```elixir
defmodule SourceSeeders do
  alias Vyasa.Repo
  alias G
  alias Vyasa.Written.{Source, Chapter, Verse, Translation}
  alias Vyasa.Medium.{Event, Voice, Video}

  @gulshan_kumar_chalisa_uri "AETFvQonfV8"
  @gita_video_uri "z4IQ4Laivtk"

  # generic
  def insert_source(uuid, source_title \\ "gita") do
    source_changeset =
      Source.gen_changeset(%Source{}, %{
        id: uuid,
        title: source_title
      })

    Repo.insert!(source_changeset)
  end

  def associate_video_to_voice(inserted_voice, video_attrs) do
    Video.gen_changeset(%Video{}, video_attrs, inserted_voice)
    |> Repo.insert()
  end

  def insert_gita_chapter(chap, source_id) do
    relevant_verses = G.get_verses_for_chapter(chap["chapter_number"], source_id)
    chap_changeset = G.create_chapter_changeset(chap, relevant_verses, source_id)
    {:ok, %Chapter{} = inserted_chapter} = Repo.insert(chap_changeset)
    %{verses: inserted_verses} = inserted_chapter

    changeset_chap_translation = G.create_chap_translation_changeset(inserted_chapter, chap)
    {:ok, %Translation{} = _inserted_chap_translation} = Repo.insert(changeset_chap_translation)

    verses_translation_changesets =
      G.create_translation_changesets_for_verses(inserted_verses, relevant_verses)

    _inserted_verse_translations =
      verses_translation_changesets
      |> Enum.map(fn c_set -> Repo.insert(c_set) end)
      |> Enum.map(fn {:ok, inserted_verse_translation} -> inserted_verse_translation end)

    chap
  end

  def insert_gita_chapters(source_id) do
    G.read_chapters()
    |> Enum.map(fn chap -> insert_gita_chapter(chap, source_id) end)
  end

  # def insert_hanuman_chalisa_verses(source_id) do 
  #   verses = H.get_verses(soure_id)

  # end

  @gita_chap_1_events """
  start :- 00:00
  Shloka 1:-    00:33
  Shloka 2 :-   00:49
  Shloka 3:-    01:06
  Shloka 4:-   01:19
  Shloka 5:-   01:32 
  Shloka 6:-   01:46
  Shloka 7:-   02:00
  Shloka 8:-   02:15
  Shloka 9:-   02:28
  Shloka 10:-  02:42
  Shloka 11:-  02:56
  Shloka 12:- 03:09
  Shloka 13:- 03:22
  Shloka 14:- 03:36
  Shloka 15:- 03:49
  Shloka 16:- 04:02
  Shloka 17:- 04:14
  Shloka 18:- 04:27
  Shloka 19:- 04:40
  Shloka 20:- 04:54
  Shloka 21:-  05:07
  Shloka 22:-  05:23
  Shloka 23:-  05:36
  Shloka 24:-  05:50
  Shloka 25:- 06:05
  Shloka 26:- 06:18
  Shloka 27:- 06:32
  Shloka 28:- 06:46
  Shloka 29:-  07:01
  Shloka 30:-  07:13
  Shloka 31:-  07:26
  Shloka 32 :-  07:38
  Shloka 33:-   07:51
  Shloka 34 :-  08:05
  Shloka 35 :-  08:18
  Shloka 36 :- 08:31
  Shloka 37:-  08:44
  Shloka 38 :- 08:57
  Shloka 39:-  09:09
  Shloka 40:-  09:22
  Shloka 41:- 09:35
  Shloka 42:- 09:48
  Shloka 43:-  10:02
  Shloka 44:-  10:16
  Shloka 45:-  10:29
  Shloka 46:-  10:40
  Shloka 47:- 10:53
  end:-  11:08
  """

  def seed_gita_chapter_1() do
    gita = Vyasa.Written.get_source_by_title("gita")
    verses = Vyasa.Written.get_verses_in_chapter(1, gita.id)

    # creats a map using verse information
    verse_lookup = Enum.into(for(%{id: id, no: verse_no} <- verses, do: {verse_no, id}), %{})

    c1_path = Path.expand("./1.mp3", "media/gita")

    {:ok,
     %Vyasa.Parser.MP3{
       duration: tot_d,
       path: p
     }} = Vyasa.Parser.MP3.parse(c1_path)

    {:ok, voice} =
      Vyasa.Medium.create_voice(%{
        lang: "sa",
        duration: tot_d,
        file_path: c1_path,
        source_id: gita.id,
        chapter_no: 1
      })

    {:ok, video} = associate_video_to_voice(voice, %{ext_uri: @gita_video_uri, type: "youtube"})

    @gita_chap_1_events
    |> String.split("\n")
    |> Enum.map(fn x ->
      x
      |> String.split(":-")
      |> Enum.map(&String.trim/1)
      |> Enum.reduce([], fn
        <<"Shloka"::utf8, sep::utf8, verse_no::binary>>, acc ->
          [verse_lookup[String.to_integer(verse_no)] | acc]

        bin, acc ->
          [bin | acc]
      end)
    end)
    |> IO.inspect(limit: :infinity)
    |> Enum.reduce(
      [],
      fn
        [time, "start"], acc ->
          [
            %Vyasa.Medium.Event{origin: 0, phase: "start", voice_id: voice.id, source_id: gita.id}
            | acc
          ]

        [time, "end"], [%{origin: o} = prev | acc] ->
          [min, sec] = time |> String.split(":") |> Enum.map(&String.to_integer/1)
          d = (min * 60 + sec) * 1000

          [
            %Vyasa.Medium.Event{
              origin: d,
              duration: tot_d - d,
              phase: "end",
              voice_id: voice.id,
              source_id: gita.id
            }
            | [%{prev | duration: d - o} | acc]
          ]

        [time, id], [%{origin: o} = prev | acc] ->
          [min, sec] = time |> String.split(":") |> Enum.map(&String.to_integer/1)
          d = (min * 60 + sec) * 1000

          [
            %Vyasa.Medium.Event{origin: d, verse_id: id, voice_id: voice.id, source_id: gita.id}
            | [%{prev | duration: d - o} | acc]
          ]

        _, acc ->
          acc
      end
    )
    |> Enum.map(&Vyasa.Medium.create_event(&1))
  end

  def seed_gita() do
    uuid = Ecto.UUID.generate()
    _source = insert_source(uuid, "gita")
    _chaps = insert_gita_chapters(uuid)
    seed_gita_chapter_1()
  end

  @chalisa_events """
    start :- 00:00
    Shloka 1:-    00:02
    Shloka 2 :-   00:24
    Shloka 3:-    00:56
    Shloka 4:-   01:07
    Shloka 5:-   01:23
    Shloka 6:-   01:33
    Shloka 7:-   01:44
    Shloka 8:-   01:55
    Shloka 9:-   02:10
    Shloka 10:-  02:21
    Shloka 11:-  02:32
    Shloka 12:- 02:43
    Shloka 13:- 02:58
    Shloka 14:- 03:09
    Shloka 15:- 03:19
    Shloka 16:- 03:30
    Shloka 17:- 03:45
    Shloka 18:- 03:54
    Shloka 19:- 04:07
    Shloka 20:- 04:18
    Shloka 21:-  04:33
    Shloka 22:-  04:44
    Shloka 23:-  04:55
    Shloka 24:-  05:05
    Shloka 25:- 05:21
    Shloka 26:- 05:32
    Shloka 27:- 05:42
    Shloka 28:- 05:53
    Shloka 29:-  06:09
    Shloka 30:-  06:19
    Shloka 31:-  06:30
    Shloka 32 :-  06:41
    Shloka 33:-   06:56
    Shloka 34 :-  07:07
    Shloka 35 :-  07:17
    Shloka 36 :- 07:28
    Shloka 37:-  07:43
    Shloka 38 :- 07:54
    Shloka 39:-  08:05
    Shloka 40:-  08:16
    Shloka 41:- 08:31
    Shloka 42:- 08:41
    Shloka 43:-  09:00
    end:-  09:42
  """
  @chalisa_audio_path Path.expand("./hanuman_chalisa_gulshan_kumar.mp3", "media/chalisa")
  def insert_hanuman_chalisa_events() do
    chalisa = Vyasa.Written.get_source_by_title("hanuman_chalisa")
    verses = Vyasa.Written.get_verses_in_chapter(1, chalisa.id)
    verse_lookup = Enum.into(for(%{id: id, no: verse_no} <- verses, do: {verse_no, id}), %{})

    # parse mp3 info: 
    {:ok,
     %Vyasa.Parser.MP3{
       duration: tot_d,
       path: p
     }} = Vyasa.Parser.MP3.parse(@chalisa_audio_path)

    # handle voices: 
    {:ok, voice} =
      Vyasa.Medium.create_voice(%{
        lang: "sa",
        duration: tot_d,
        file_path: @chalisa_audio_path,
        source_id: chalisa.id,
        chapter_no: 1
      })

    # handle video: 
    {:ok, video} =
      associate_video_to_voice(voice, %{ext_uri: @gulshan_kumar_chalisa_uri, type: "youtube"})

    # now handle the events: 
    @chalisa_events
    |> String.split("\n")
    |> Enum.map(fn x ->
      x
      |> String.split(":-")
      |> Enum.map(&String.trim/1)
      |> Enum.reduce([], fn
        <<"Shloka"::utf8, sep::utf8, verse_no::binary>>, acc ->
          [verse_lookup[String.to_integer(verse_no)] | acc]

        bin, acc ->
          [bin | acc]
      end)
    end)
    |> IO.inspect(limit: :infinity)
    |> Enum.reduce(
      [],
      fn
        [time, "start"], acc ->
          [
            %Vyasa.Medium.Event{
              origin: 0,
              phase: "start",
              voice_id: voice.id,
              source_id: chalisa.id
            }
            | acc
          ]

        [time, "end"], [%{origin: o} = prev | acc] ->
          [min, sec] = time |> String.split(":") |> Enum.map(&String.to_integer/1)
          d = (min * 60 + sec) * 1000

          [
            %Vyasa.Medium.Event{
              origin: d,
              duration: tot_d - d,
              phase: "end",
              voice_id: voice.id,
              source_id: chalisa.id
            }
            | [%{prev | duration: d - o} | acc]
          ]

        [time, id], [%{origin: o} = prev | acc] ->
          [min, sec] = time |> String.split(":") |> Enum.map(&String.to_integer/1)
          d = (min * 60 + sec) * 1000

          [
            %Vyasa.Medium.Event{
              origin: d,
              verse_id: id,
              voice_id: voice.id,
              source_id: chalisa.id
            }
            | [%{prev | duration: d - o} | acc]
          ]

        _, acc ->
          acc
      end
    )
    |> Enum.map(&Vyasa.Medium.create_event(&1))
  end

  @chalisa_chap_body "The Hanuman Chalisa, composed by Goswami Tulsidas, is a  40-verse hymn dedicated to Lord Hanuman, highlighting his unwavering devotion to Lord Rama. It is a testament to Hanuman's strength, wisdom, and courage, as well as his role in Lord Rama's epic battles against evil. Reciting this hymn is believed to bestow blessings and protection from Hanuman, fostering spiritual growth and devotion to Lord Rama."
  def insert_hanuman_chalisa_chapter(source, chalisa_verses) do
    {:ok, inserted_chap} =
      Chapter.changeset(
        %Chapter{
          no: 1,
          source_id: source.id,
          title: "Hanuman Chalisa",
          body: @chalisa_chap_body
        },
        %{
          verses:
            chalisa_verses
            |> Enum.map(fn v ->
              %{
                no: v["count"],
                body: v["verse_sanskrit"],
                source_id: source.id
              }
            end)
        }
      )
      |> Repo.insert()
      |> dbg()

    Translation.gen_changeset(
      %Translation{},
      %{
        lang: "en",
        body: @chalisa_chap_body,
        target: %{
          title: "Hanuman Chalisa",
          translit_tile: "Hanuman Chalisa",
          body: @chalisa_chap_body
        },
        source_id: source.id
      },
      inserted_chap
    )
    |> Repo.insert()
    |> dbg()

    inserted_chap
  end

  def insert_hanuman_chalisa_verses(source, chalisa_verses) do
    chalisa_verses
    |> Enum.map(fn v ->
      Verse.changeset(%Verse{}, %{
        no: v["count"],
        body: v["verse_sanskrit"],
        source_id: source.id
      })
    end)
    |> Enum.map(fn chset -> Repo.insert(chset) end)
    |> Enum.map(fn {:ok, inserted_v} -> inserted_v end)
  end

  def insert_hanuman_chalisa_verse_translations(
        %Chapter{verses: inserted_verses} = _inserted_chap,
        chalisa_verses
      ) do
    inserted_verses
    |> Enum.zip(chalisa_verses)
    |> Enum.map(fn {inserted_verse, v} ->
      Translation.gen_changeset(
        %Translation{},
        %{
          lang: "en",
          target: %{
            body: v["verse_sanskrit"],
            body_translit_meant: v["verse_meaning"],
            body_translit: v["verse_trans"]
          },
          source_id: inserted_verse.source_id,
          # chapter_no: inserted_verse.chapter_no, # this assoc isn't supposed to be done @ verse-trans creation
          verse_id: inserted_verse.id
        },
        inserted_verse
      )
    end)
    |> Enum.map(fn trans_cset -> Repo.insert(trans_cset) end)
    |> Enum.map(fn outcome -> elem(outcome, 1) end)
    |> dbg()
  end

  def seed_hanuman_chalisa() do
    uuid = Ecto.UUID.generate()
    %{"verses" => chalisa_verses} = _verse_info = H.read_verses()

    uuid
    |> insert_source("hanuman_chalisa")
    |> insert_hanuman_chalisa_chapter(chalisa_verses)
    |> insert_hanuman_chalisa_verse_translations(chalisa_verses)

    insert_hanuman_chalisa_events()
  end
end
```

#### DB Convenience Actions

* purging of db
* seeding of db

```elixir
defmodule DBHelper do
  alias SourceSeeders
  alias Vyasa.Repo
  alias G
  alias Vyasa.Written.{Source, Chapter, Verse, Translation}
  alias Vyasa.Medium.{Video, Event, Voice}

  # alias Vyasa.Medium.{Voice, Event, Store, Track, Video, Writer}

  def purge_db() do
    [Video, Event, Voice, Translation, Verse, Chapter, Source]
    |> Enum.map(fn mod -> Repo.delete_all(mod) end)
  end

  def seed_db() do
    SourceSeeders.seed_gita()
    SourceSeeders.seed_hanuman_chalisa()
  end
end
```

#### Testing the purging and seeding of the db:

```elixir
R.recompile()
DBHelper.purge_db()
DBHelper.seed_db()
```

### Exploring video-voice sync

The following is a demo check that the seeding is working correctly. Once verified, the block may be removed.

```elixir
R.recompile()

alias Vyasa.Written
alias Vyasa.Written.{Source}
alias Vyasa.Medium.{Voice, Video}
alias Vyasa.Medium
alias Vyasa.Repo

%Source{id: chalisa_id} = chalisa = Written.get_source_by_title("hanuman_chalisa")
h_voice = Repo.get_by!(Voice, source_id: chalisa_id) |> Repo.preload([:video])

%Source{id: gita_id} = gita = Written.get_source_by_title("gita")
g_voice = Repo.get_by!(Voice, source_id: gita_id) |> Repo.preload([:video])

g_voice.video |> Medium.resolve_video_url()

Medium.get_voice(chalisa_id, 1, "sa")
```

```elixir

```
